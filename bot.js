const Discord = require('discord.js');
const client = new Discord.Client();

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});

// ÙƒÙˆØ¯ Ø§Ø¹Ø·Ø§ Ø§Ù„Ø¹Ø¶Ùˆ Ø±ØªØ¨Ø© Ø§ÙˆÙ„ Ù…Ø§ ÙŠØ¯Ø®Ù„ Ø§Ù„Ø³ÙŠØ±ÙØ±

client.on('guildMemberAdd', member=> {
    member.addRole(member.guild.roles.find("name","â€¢ OmEGa Â» Member"));
    });


// Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ùˆ Ø§Ù„ÙˆØµÙ

client.on('ready', () => {
     client.user.setActivity("!~[ OMEGA CODE ]~!",{type: 'WATCHING'})

});





 client.on('ready', function(){
    client.user.setStatus("idle");
    var ms = 1 ;

});


// ÙƒÙˆØ¯ Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øª
client.on("message", message => {
	var prefix = "!"
    var args = message.content.substring(prefix.length).split(" ");
    if (message.content.startsWith(prefix + "clear")) {
        if(!message.channel.guild) return message.reply('**:x: Ø§Ø³Ù Ù„ÙƒÙ† Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª ÙÙ‚Ø· **');         
if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('**âš   Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øª**');
var msg;
msg = parseInt();

message.channel.fetchMessages({limit: msg}).then(messages => message.channel.bulkDelete(messages)).catch(console.error);
message.channel.sendMessage("", {embed: {
title: "``ØªÙ€Ù€Ù… Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øª ``",
color: 0x06DF00,
footer: {
  
}
}}).then(msg => {msg.delete(3000)});
                  }


});

// ÙƒÙˆØ¯ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª

client.on('message', message => {
if(message.author.bot) return;
              if(!message.channel.guild) return;
    var prefix = "!";
    if(message.content.startsWith(prefix + 'bc')) {
    if(!message.channel.guild) return message.channel.send('**Ø§Ù„Ø£Ù…Ø± Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±Ø§Øª Ø¨Ø³**').then(m => m.delete(5000));
  if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ù…Ø§Ø¹Ù†Ø¯Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©**' );
    let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
    let copy = "";
    let request = `ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ù…Ù†  ${message.author.username}`;
    if (!args) return message.reply('**ØªØ±Ø³Ù„ Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª ÙØ§Ø¶ÙŠØŸ**');message.channel.send(`**Ù…ØªØ£ÙƒØ¯ØŸ** \` ${args}\``).then(msg => {
    msg.react('âœ…')
    .then(() => msg.react('âŒ'))
    .then(() =>msg.react('âœ…'))

    let reaction1Filter = (reaction, user) => reaction.emoji.name === 'âœ…' && user.id === message.author.id;
    let reaction2Filter = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === message.author.id;

    let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
    let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
    reaction1.on("collect", r => {
    message.channel.send(`**â˜‘ | ØªÙ… ... Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª  ${message.guild.members.size} Ø¹Ø¶Ùˆ**`).then(m => m.delete(5000));
    message.guild.members.forEach(m => {
    var bc = new
       Discord.RichEmbed()
       .setColor('#00ff47')
       .setTitle('**:incoming_envelope:Ø±Ø³Ø§Ù„Ø©:incoming_envelope:')
       .addField('**:diamond_shape_with_a_dot_inside:Ø§Ù„Ø³ÙŠØ±ÙØ±:diamond_shape_with_a_dot_inside:**', message.guild.name)
       .addField('**:black_joker:Ø§Ù„Ù…Ø±Ø³Ù„:black_joker:**', message.author.username)
       .addField(':page_facing_up:Ø§Ù„Ø±Ø³Ø§Ù„Ø©:page_facing_up:', args)
       .setThumbnail(message.author.avatarURL)
       .setFooter(copy, client.user.avatarURL);
    m.send({ embed: bc })
    msg.delete();
    })
    })
    reaction2.on("collect", r => {
    message.channel.send(`**ÙƒÙ†Ø³Ù„ ÙŠØ§ Ù…Ø¯ÙŠØ±**`).then(m => m.delete(5000));
    msg.delete();
    })
    })
    }
let cooldown = new Set();
let cdseconds = 5;
if(!message.content.startsWith(prefix)) return;
  if(cooldown.has(message.author.id)){
    message.delete();
  return  message.reply("Ø§Ù„ØµØ¨Ø± ÙŠØ§ Ø£Ø®ÙŠ")
  }
  if(!message.member.hasPermission("ADMINISTRATOR")){
    cooldown.add(message.author.id);
  }
setTimeout(() => {
  cooldown.delete(message.author.id)
}, cdseconds * 1000)
    });
	
	// ÙƒÙˆØ¯ Ø§Ù„Ø§ÙŠØ¯ÙŠ
	
	var moment = require("moment");
client.on('message', message => {
if(message.author.bot) return;
  var prefix = '!';
  
  if (message.content.startsWith(prefix + "id")) {
      message.react("ğŸ†”") 
  if(!message.channel.guild) return message.reply(`**__Ø¨Ø³ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±Ø§Øª__**`);
   message.guild.fetchInvites().then(invs => {
      let member = client.guilds.get(message.guild.id).members.get(message.author.id);
      let personalInvites = invs.filter(i => i.inviter.id === message.author.id);
      let inviteCount = personalInvites.reduce((p, v) => v.uses + p, 0);
      var moment = require('moment');
      var args = message.content.split(" ").slice(1);
let user = message.mentions.users.first();
var men = message.mentions.users.first();
 var heg;
 if(men) {
     heg = men
 } else {
     heg = message.author
 }
var mentionned = message.mentions.members.first();
  var h;
 if(mentionned) {
     h = mentionned
 } else {
     h = message.member
 }
moment.locale('ar-TN');
      var id = new  Discord.RichEmbed()
    .setColor("!0a0909")
    .setAuthor(message.author.username, message.author.avatarURL) 
.addField('**ØªØ§Ø±ÙŠØ® Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø¯Ø³ÙƒÙˆØ±Ø¯**:', `${moment(heg.createdTimestamp).format('YYYY/M/D HH:mm:ss')} **\n** \`${moment(heg.createdTimestamp).fromNow()}\`` ,true) 
.addField('**ØªØ§Ø±ÙŠØ® Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø³ÙŠØ±ÙØ±**:', `${moment(h.joinedAt).format('YYYY/M/D HH:mm:ss')} \n \`${moment(h.joinedAt).fromNow()}\``, true)
.addField("**Ø§Ø³Ù…Ùƒ**", `${message.author.username}`)
.addField('**ØªØ§Ù‚Ùƒ**', message.author.discriminator)
.addField('**Ø§ÙŠØ¯ÙŠÙƒ**', message.author.id)
.addField('**Ø³Ù€ÙŠÙ€Ø±ÙÙ€Ø±**', `${member.guild.name}`,true)
.setFooter("ã€Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒã€")  
    message.channel.sendEmbed(id);
})
}       
});


// Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±

client.on('message', function(msg) {
	var prefix = "!"
    if(msg.content.startsWith (prefix  + 'server')) {
      message.react("ğŸ¤–") 
      let embed = new Discord.RichEmbed()
      .setColor('#00ff47')
      .setThumbnail(msg.guild.iconURL)
      .setTitle(`**Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±**`)
      .addField('ğŸŒ**__Ø¯ÙˆÙ„Ø© Ø§Ù„Ø³ÙŠØ±ÙØ±__**',`ã€** __${msg.guild.region}__ **ã€`,true)
      .addField(':star:** __Ø¹Ø¯Ø¯ Ø§Ù„Ø±ØªØ¨__**',`ã€** __${msg.guild.roles.size}__ **ã€`,true)
      .addField(':black_heart:**__ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡__**',`ã€** __${msg.guild.memberCount}__ **ã€`,true)
      .addField(':green_heart:**__ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†__**',`ã€** __${msg.guild.members.filter(m=>m.presence.status == 'online').size}__ **ã€`,true)
      .addField('ğŸ“**__ Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ÙƒØªØ§Ø¨ÙŠØ©__**',`ã€** __${msg.guild.channels.filter(m => m.type === 'text').size}__** ã€`,true)
      .addField('ğŸ¤**__ Ø±ÙˆÙ…Ø§Øª Ø§Ù„ØµÙˆØª__**',`ã€** __${msg.guild.channels.filter(m => m.type === 'voice').size}__ **ã€`,true)
      .addField('ğŸ‘‘**__ Ø§Ù„Ø£ÙˆÙ†Ù€Ø±__**',`**ã€${msg.guild.owner}ã€**`,true)
      .addField('ğŸ†”**__ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±__**',`**ã€${msg.guild.id}ã€**`,true)
      .addField(':calendar_spiral:**__ ØµÙ†Ø¹ Ø§Ù„Ø³ÙŠØ±ÙØ± ÙÙŠ__**',msg.guild.createdAt.toLocaleString())
      msg.channel.send({embed:embed});
    }
  });
  
  // Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø±ÙˆÙ…
  
  client.on('message', message => {
    if(!message.channel.guild) return;
var prefix = "!";
if(message.content.startsWith(prefix + 'ch')) {
    let channel = message.channel
    var embed = new Discord.RichEmbed()
      .setTitle("Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø±ÙˆÙ…")
      .setColor("RANDOM")
      .setDescription(`Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø±ÙˆÙ… <#${channel.id}>\nChannel ID: ${channel.id}`)
      .addField("ØµÙ†Ø¹ ÙÙŠ", `${channel.createdAt}`)
      .addField("Ù†ÙˆØ¹ Ø§Ù„Ø±ÙˆÙ…", `${channel.type}`)
      .addField("Extra Information", `Channel is NSFW => ${channel.nsfw}\nChannel Topic=> ${channel.topic}\nChannel Parent => ${channel.parent}\nChannel Position => ${channel.position}`)
 
     message.channel.send({ embed: embed });
  }
 
    });


client.on('message', message => {
	var prefix = "!"
if(message.author.bot) return;
    var name1 = message.mentions.users.first();
    var reason = message.content.split(' ').slice(2).join(' ');
    if(message.content.startsWith(prefix + 'report')) {
        if(message.author.bot) return;
        if(!message.guild.channels.find('name', 'report')) return message.channel.send('**Ù†Ø±Ø¬ÙˆØ§ Ø¹Ù…Ù„ Ø±ÙˆÙ… Ø¨Ø§Ø³Ù… Ø§Ù„Ø§Ø¨Ù„Ø§ØºØ§Øª ÙƒÙŠ ØªÙˆØµÙ„ Ø§Ù„Ø§Ø¨Ù„Ø§ØºØ§Øª Ù„Ù‡**').then(msg => msg.delete(5000));
    if(!name1) return message.reply('**:innocent:Ù…Ù†Ø´Ù†:innocent:**').then(msg => msg.delete(3000))
        message.delete();
    if(!reason) return message.reply('**:innocent:ÙˆØ´ Ø³ÙˆÙ‰ØŸ:innocent:**').then(msg => msg.delete(3000))
        message.delete();
    var abod = new Discord.RichEmbed()
    .setTitle(`Ø¨Ù„Ø§Øº Ù…Ù† Ù‚Ø¨Ù„: ${message.author.tag}`)
    .addField('**Ø§Ù„Ù…Ø¬Ø±Ù…:**', `${name1}`, true)
    .addField('**Ø¨Ø±ÙˆÙ…:**', `${message.channel.name}`, true)
    .addField('**Ø§Ù„Ø¨Ù„Ø§Øº:**', `${reason}`, true)
    .setFooter(`${message.author.username}#${message.author.discriminator}`, message.author.avatarURL)
    .setTimestamp()
        message.guild.channels.find('name', 'report').sendEmbed(abod)
    message.reply('**:sunglasses:Ø¨Ù†Ø£Ø®Ø° Ø­Ù‚Ùƒ:sunglasses:**').then(msg => msg.delete(3000));
    }
});


client.on("message", message => {
if(message.author.bot) return;
      if (message.content === "!ping") {
      message.react("ğŸ“¶") 
      const embed = new Discord.RichEmbed()
  .setColor("#00ff47")
  .addField('**Ø³Ø±Ø¹Ø© Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ø¨ÙˆØª:**' , `${Date.now() - message.createdTimestamp}` + ' ms')
  message.channel.sendEmbed(embed);
    }









const bannedwords = [
    "ÙƒÙ„ Ø²Ù‚",
    "ÙƒØ³Ù…Ùƒ",
    "ÙƒÙ„Ø¨",
    "ÙŠØ§ Ø´Ø±Ù…ÙˆØ·",
    "ÙƒÙ„ Ø²Ù‚ Ùˆ Ø§Ø³ÙƒØª",
    "Ø¨ÙˆØª Ø²Ù‚"

  ];

client.on('message',  message => {
  if(bannedwords.some(word => message.content.includes(word))) {
    message.delete()
    message.reply(" Ø§Ø­ØªØ±Ù… Ù†ÙØ³Ùƒ , ÙŠÙ…Ù†Ø¹ Ø§Ù„Ø´ØªÙ… ÙÙŠ Ø®Ø§Ø¯Ù…Ù†Ø§ Ø§Ùˆ Ø³ÙˆÙ ØªØªØ¹Ø±Ø¶ Ø§Ù„ÙŠ  Ù…ÙŠÙˆØª ").then(msg => {msg.delete(5000)});;
  };
});         


client.on('message', message => {
var prefix = "!"
    if (message.content.startsWith("avatar")) {
        var mentionned = message.mentions.users.first();
    var x5bzm;
      if(mentionned){
          var x5bzm = mentionned;
      } else {
          var x5bzm = message.author;
          
      }
        const embed = new Discord.RichEmbed()
        .setColor("RANDOM")
        .setImage(`${x5bzm.avatarURL}`)
      message.channel.sendEmbed(embed);
    }
});


client.on('message', message => {
	var prefix = "!"
  if (message.author.x5bz) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "ban") {
               if(!message.channel.guild) return message.reply('** This command only for servers**');
         
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**You Don't Have ` BAN_MEMBERS ` Permission**");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  let reason = message.content.split(" ").slice(2).join(" ");
  /*let b5bzlog = client.channels.find("name", "5bz-log");

  if(!b5bzlog) return message.reply("I've detected that this server doesn't have a 5bz-log text channel.");*/
  if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø´Ø®Øµ**");
  if(!reason) return message.reply ("**Ø§ÙƒØªØ¨ Ø³Ø¨Ø¨ Ø§Ù„Ø·Ø±Ø¯**");
  if (!message.guild.member(user)
  .bannable) return message.reply("**Ù„Ø§ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø·Ø±Ø¯ Ø´Ø®Øµ Ø§Ø¹Ù„Ù‰ Ù…Ù† Ø±ØªØ¨ØªÙŠ ÙŠØ±Ø¬Ù‡ Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª Ø±ØªØ¨Ù‡ Ø¹Ø§Ù„ÙŠ**");

  message.guild.member(user).ban(7, user);

  const banembed = new Discord.RichEmbed()
  .setAuthor(`BANNED!`, user.displayAvatarURL)
  .setColor("RANDOM")
  .setTimestamp()
  .addField("**User:**",  '**[ ' + `${user.tag}` + ' ]**')
  .addField("**By:**", '**[ ' + `${message.author.tag}` + ' ]**')
  .addField("**Reason:**", '**[ ' + `${reason}` + ' ]**')
  message.channel.send({
    embed : banembed
  })
}
});

        
client.on('message', message => {
var prefix = "!"
    if(message.content.startsWith(prefix + 'new')) {
        let args = message.content.split(' ').slice(1).join(' ');
        let support = message.guild.roles.find("name","Support Team");
        let ticketsStation = message.guild.channels.find("name", "TICKETS");
        if(!args) {
            return message.channel.send('Ø§Ù„Ø±Ø¬Ø£Ø¡ Ø¶Ø¹ Ø³Ø¨Ø¨ Ø§Ù„ØªØ°ÙƒØ±Ø©.');
        };
                if(!support) {
                    return message.channel.send('**Please make sure that `Support Team` role exists and it\'s not duplicated.**');
                };
            if(!ticketsStation) {
                message.guild.createChannel("TICKETS", "category");
            };
                message.guild.createChannel(`ticket-${message.author.username}`, "text").then(ticket => {
                    message.delete()
                        message.channel.send(`Ù„Ù‚Ø¯ ØªÙ… Ø§Ù†Ø´Ø§Ø¡ ØªØ°ÙƒØ±ØªÙƒ. [ ${ticket} ]`);
                    ticket.setParent(ticketsStation);
                    ticketsStation.setPosition(1);
                        ticket.overwritePermissions(message.guild.id, {
                            SEND_MESSAGES: false,
                            READ_MESSAGES: false
                        });
                            ticket.overwritePermissions(support.id, {
                                SEND_MESSAGES: true,
                                READ_MESSAGES: true
                            });
                                ticket.overwritePermissions(message.author.id, {
                                    SEND_MESSAGES: true,
                                    READ_MESSAGES: true
                                });
                    let embed = new Discord.RichEmbed()
                                .setTitle('**ØªØ°ÙƒØ±Ø© Ø¬Ø¯ÙŠØ¯Ø©.**')
                                .setColor("RANDOM")
                                .setThumbnail(`${message.author.avatarURL}`)
                                .addField('Ø§Ù„Ø³Ø¨Ø¨', args)
                                .addField('ØµØ§Ø­Ø¨ Ø§Ù„ØªØ°ÙƒØ±Ø©', message.author)
                                .addField('Ø§Ù„Ø±ÙˆÙ…', `<#${message.channel.id}>`);
 
                                ticket.sendEmbed(embed);
                }) .catch();
    }
    if(message.content.startsWith(prefix + 'close')) {
            if(!message.member.hasPermission("ADMINISTRATOR")) return;
        if(!message.channel.name.startsWith("ticket")) {
            return;
        };  
                let embed = new Discord.RichEmbed()
                    .setAuthor("Ù‡Ù„ Ø§Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø§Ù†Ùƒ ØªØ±ÙŠØ¯ Ø§ØºÙ„Ø§Ù† Ø§Ù„ØªØ°ÙƒØ±Ø© ØŸ Ù„Ø¯ÙŠÙƒ 20 Ø«Ø§Ù†ÙŠØ© Ù„ÙƒÙŠ ØªÙ‚Ø±Ø±.")
                    .setColor("RANDOM");
                    message.channel.sendEmbed(embed) .then(codes => {
 
                   
                        const filter = msg => msg.content.startsWith(prefix + 'yes');
                        message.channel.awaitMessages(response => response.content === prefix + 'yes', {
                            max: 1,
                            time: 20000,
                            errors: ['time']
                        })
                        .then((collect) => {
                            message.channel.delete();
                        }) .catch(() => {
                            codes.delete()
                                .then(message.channel.send('**Operation has been cancelled.**')) .then((c) => {
                                    c.delete(4000);
                                })
                                   
                           
                        })
 
 
                    })
 
 
           
    }
});

const code = '!';//prefix
 
client.on('message',async message => {
    if(message.content.startsWith(code + "code")) {
  if(!message.channel.guild) return message.reply('This Command For Servers Only !');
    let jscodes = message.guild.channels.find(`name`, "âœµ-ã€Œdiscord-js");
    if(!jscodes) return message.channel.send(":x:Ù„Ù… Ø§Ø¬Ø¯ Ø§Ù„Ø±ÙˆÙ… Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø´Ø± Ø§Ù„Ø§ÙƒÙˆØ§Ø¯");
      let filter = m => m.author.id === message.author.id;
      let thisMessage;
      let thisFalse;
      message.channel.send(':pencil: **| Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£Ù†... :pencil2: **').then(msg => {
 
      message.channel.awaitMessages(filter, {
        max: 1,
        time: 90000,
        errors: ['time']
      })
      .then(collected => {
        collected.first().delete();
        thisMessage = collected.first().content;
        let boi;
        msg.edit(':scroll: **| Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ ÙˆØµÙ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£Ù†... :pencil2: **').then(msg => {
 
            message.channel.awaitMessages(filter, {
              max: 1,
              time: 90000,
              errors: ['time']
            })
            .then(collected => {
              collected.first().delete();
              boi = collected.first().content;
              let boi2;
              msg.edit(':man_in_tuxedo: **| Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ù…Ù† ØµÙ†Ø¹ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£Ù†... :pencil2: **').then(msg => {
 
                message.channel.awaitMessages(filter, {
                  max: 1,
                  time: 90000,
                  errors: ['time']
                })
                .then(collected => {
                  collected.first().delete();
                boi2 = collected.first().content;
        msg.edit(':shield: **| [ Ù‡Ù„ Ø§Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù†Ø´Ø± Ø§Ù„ÙƒÙˆØ¯ØŸ | [ Ù†Ø¹Ù… ] Ø§Ùˆ [ Ù„Ø§**');
   message.channel.awaitMessages(response => response.content === 'Ù†Ø¹Ù…' || 'Ù„Ø§' && filter,{
          max: 1,
          time: 90000,
          errors: ['time']
        })
        .then(collected => {
          if(collected.first().content === 'Ù„Ø§') {
            msg.delete();
            message.delete();
            thisFalse = false;
          }
          if(collected.first().content === 'Ù†Ø¹Ù…') {
            if(thisFalse === false) return;
            msg.edit(':dove: **| Done :white_check_mark:, ØªÙ… Ø¨Ù†Ø¬Ø§Ø­ Ù†Ø´Ø± ÙƒÙˆØ¯Ùƒ ÙÙŠ Ø±ÙˆÙ… Ø§Ù„Ø§ÙƒÙˆØ§Ø¯**');
            collected.first().delete();
            jscodes.send(`@everyone | @here
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
**${message.guild.name}Â© :arrow_down:**            
\`\`\`js
${thisMessage}\`\`\`
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
**ÙˆØµÙ Ø§Ù„ÙƒÙˆØ¯**: ${boi}
**ØªÙ… Ø§Ù„Ù†Ø´Ø± Ø¨ÙˆØ§Ø³Ø·Ø©** : ${message.author}
**Ø§Ù„Ù…ØµØ¯Ø± / Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ø°ÙŠ ØµÙ†Ø¹ Ø§Ù„ÙƒÙˆØ¯**:  ${boi2}`);
          }
        }
    );
});
      });
    }
      );
    });
}
);
      })}});





client.on('message', msg => {
    if(msg.content.startsWith('!link')) {
    if(msg.channel.type === 'dm') return;
const user = msg.mentions.users.first();
if(!user) return msg.channel.send('``' + '**Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ¯ Ø¨ÙˆØª**' + '``')
if(!user.bot) return msg.reply('\`Ù…Ù†Ø´Ù† Ø¨ÙˆØª\`');
msg.channel.send(`**Bot InviteURL : ** https://discordapp.com/oauth2/authorize?client_id=${user.id}&scope=bot&permissions=384064`)
    }
});          
          
client.on('message', message => { 

if (message.author.bot) return;

var prefix = "!";

if (!message.content.startsWith(prefix)) return;

let command = message.content.split(" ")[0];

command = command.slice(prefix.length);

let args = message.content.split(" ").slice(1);

if (command == "mute") {

if(!message.channel.guild) return message.reply(':no_entry: | This Command For Servers Only!'); 

Â Â Â Â Â Â Â Â if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | You dont have **MANAGE_ROLES** Permission!');

Â Â Â Â Â Â Â Â if(!message.guild.member(client.user).hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | I dont have **MANAGE_ROLES** Permission!');

let user = message.mentions.users.first();

let muteRole = message.guild.roles.find("name", "Muted");

if (!muteRole) return message.reply(":no_entry: Error | Ù„Ø§ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø§ÙŠØ¬Ø§Ø¯ 'Muted' Ø±ØªØ¨Ø©").then(msg => {msg.delete(5000)});

if (message.mentions.users.size < 1) return message.reply('**â¥ Ø§Ø³ØªØ®Ø¯Ù…:** !mute \`\`@Name\`\` reason');

let reason = message.content.split(" ").slice(2).join(" ");

message.guild.member(user).addRole(muteRole);

const muteembed = new Discord.RichEmbed()

.setColor("RANDOM")

.setAuthor(`Muted!`, user.displayAvatarURL)

.setThumbnail(user.displayAvatarURL)

.addField("**:busts_in_silhouette: Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…**", '**[ ' + `${user.tag}` + ' ]**',true)

.addField("**:hammer: ØªÙ… Ø¨ÙˆØ§Ø³Ø·Ø© **", '**[ ' + `${message.author.tag}` + ' ]**',true)

.addField("**:book: Ø§Ù„Ø³Ø¨Ø¨**", '**[ ' + `${reason}` + ' ]**',true)

.addField("User", user, true) 

Â Â .setTitle('**[MUTED]**')

		.setThumbnail(message.author.avatarURL)

		.setColor('GREEN')

		.setDescription(`**\n:zipper_mouth: Successfully \`\`MUTED\`\` **${user.username}** From the server!\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${message.author.id}> (ID: ${message.author.id})\n**Reason:** \`\`${reason}\`\``)

		.setTimestamp()

		.setFooter(user.tag, user.avatarURL)

client.channels.find('name', "log").send({embed : muteembed});

}


if (command == "unmute") {

if(!message.channel.guild) return message.reply(':no_entry: | This Command For Servers Only!'); 

Â Â Â Â Â Â Â Â if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | You dont have **MANAGE_ROLES** Permission!');

Â Â Â Â Â Â Â Â if(!message.guild.member(client.user).hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | I dont have **MANAGE_ROLES** Permission!');

let user = message.mentions.users.first();

let muteRole = message.guild.roles.find("name", "Muted");

if (!muteRole) return message.reply(":no_entry: Error | I Cant find 'Muted' Role").then(msg => {msg.delete(5000)});

if (message.mentions.users.size < 1) return message.reply('**â¥ Ø§Ø³ØªØ®Ø¯Ù…:** !unmute \`\`@Name\`\`');

let reason = message.content.split(" ").slice(2).join(" ");

message.guild.member(user).removeRole(muteRole);

const unmuteembed = new Discord.RichEmbed()

.setTitle('**[UNMUTED]**')

			.setThumbnail(message.author.avatarURL)

			.setColor('GREEN')

			.setDescription(`**\n:zipper_mouth: Successfully \`\`UNMUTED\`\` **${user.username}** From the server!\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${message.author.id}> (ID: ${message.author.id})`)

			.setTimestamp()

			.setFooter(user.tag, user.avatarURL)

client.channels.find('name', "log").send({embed : unmuteembed});

}

});

client.on('message', async message => {
    var command = message.content.toLowerCase().split(" ")[0];
    var prefix = '!';// Alpha Codes
    var name = '';// Alpha Codes
    var age = '';// Alpha Codes
    var fromwhere = '';// Alpha Codes
    var fa2dh = '';// Alpha Codes
    var filter = m => m.author.id === message.author.id;// Alpha Codes
    var subChannel = message.guild.channels.find(c => c.name === 'âœµ-ã€Œaccept-support');// Alpha Codes
   
    if(command == prefix + 'apply') {// Alpha Codes
        if(message.author.bot) return;
        if(message.channel.type === 'dm') return;
 
        var modRole = message.guild.roles.find(r => r.name === 'â€¢ OmEGa Â» Support');// Alpha Codes
       
        if(message.guild.member(message.author).roles.has(modRole.id)) return message.channel.send(':x: | Ù…Ø¹Ùƒ Ø§Ù„Ø±ØªØ¨Ø©');// Alpha Codes
        if(!subChannel) return message.channel.send(':x: | ÙŠØ¬Ø¨ Ø§Ù† ÙŠØªÙˆÙØ± Ø±ÙˆÙ… Ø§Ø³Ù…Ù‡ `moderator-apply`');// Alpha Codes
       
        message.channel.send(':timer: | **Ø§ÙƒØªØ¨ Ø§Ø³Ù…Ùƒ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø§Ù„Ø§Ù† Ù…Ù† ÙØ¶Ù„Ùƒ**').then(msgS => {
            message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'] }).then(collected => {
                name = collected.first().content;
                collected.first().delete();
                msgS.edit(':timer: | **Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø¹Ù…Ø±Ùƒ Ø§Ù„Ø§Ù†**').then(msgS => {
                    message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'] }).then(collected => {
                        age = collected.first().content;
                        collected.first().delete();
                        msgS.edit(':timer: | **Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ù…Ù† Ø§ÙŠ Ø¨Ù„Ø¯ Ø§Ù†Øª**').then(msgS => {
                            message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'] }).then(collected => {
                                fromwhere = collected.first().content;
                                collected.first().delete();
                                msgS.edit(':timer: | **Ù…Ø¹Ùƒ Ø®Ø¨Ø±Ø© Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ ØŸ**').then(msgS => {
                                    message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'] }).then(collected => {
                                        fa2dh = collected.first().content;
                                        collected.first().delete();
                                       
                                        let embedS = new Discord.RichEmbed()
                                        .setAuthor(message.author.tag, message.author.avatarURL)
                                        .setThumbnail(message.author.avatarURL)
                                        .setDescription('**\n:no_entry: Ù‡Ù„ Ø§Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø§Ù†Ùƒ ØªØ±ÙŠØ¯ Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…ØŸ**')
                                        .setColor('GREEN')
                                        .addField('Ø§Ù„Ø§Ø³Ù…', name, true)
                                        .addField('Ø§Ù„Ø¹Ù…Ø±', age, true)
                                        .addField('Ù…Ù† ÙˆÙŠÙ†', fromwhere, true)
                                        .addField('Ù…Ø¹Ùƒ Ø®Ø¨Ø±Ø© Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ ØŸ', fa2dh, true)
                                        .setTimestamp()
                                        .setFooter(message.guild.name, message.guild.iconURL)
                                       
                                        msgS.delete();
                                        message.channel.send(embedS).then(msgS => {
                                            msgS.react('â›”').then(() => msgS.react('âœ…'))
                                           
                                            let yesSure = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                                            let no = (reaction, user) => reaction.emoji.name === 'â›”' && user.id === message.author.id;
                                           
                                            let yesSend = msgS.createReactionCollector(yesSure);
                                            let dontSend = msgS.createReactionCollector(no);
                                           
                                            yesSend.on('collect', r => {
                                                msgS.delete();
                                                message.channel.send(':white_check_mark: | ØªÙ… ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨Ùƒ Ù„Ù„Ø§Ø¯Ø§Ø±Ø© ').then(msg => msg.delete(5000));
                                               
                                                let subMsg = new Discord.RichEmbed()
                                                .setAuthor(message.author.tag, message.author.avatarURL)
                                                .setColor('GREEN')
                                                .setThumbnail(message.author.avatarURL)
                                                .addField('Ø§Ù„Ø§Ø³Ù…', name)
                                                .addField('Ø§Ù„Ø¹Ù…Ø±', age)
                                                .addField('Ù…Ù† ÙˆÙŠÙ†', fromwhere)
                                                .addField('Ù…Ø¹Ùƒ Ø®Ø¨Ø±Ø© Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ ØŸ', fa2dh)
                                                .addField('Ø­Ø³Ø§Ø¨Ù‡', message.author)
                                                .addField('Ø§ÙŠØ¯ÙŠ Ø­Ø³Ø§Ø¨Ù‡', message.author.id, true)
                                               
                                                subChannel.send(subMsg).then(msgS => {
                                                    msgS.react('âœ…').then(() => msgS.react('â›”'))
                                                   
                                                    let accept = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === '467782642549653514'
                                                    let noAccept = (reaction, user) => reaction.emoji.name === 'â›”' && user.id === '484683624495448064'
                                                   
                                                    let acceptRe = msgS.createReactionCollector(accept);
                                                    let noAcceptRe = msgS.createReactionCollector(noAccept);
                                                   
                                                    acceptRe.on('collect', r => {
                                                        msgS.delete();
                                                        message.author.send(`:white_check_mark: | ØªÙ… Ù‚Ø¨ÙˆÙ„Ùƒ ÙƒÙ€ Ø³Ø¨ÙˆØ±Øª **${message.guild.name}**`);
                                                        message.guild.member(message.author).addRole(modRole.id);
                                                        message.guild.channels.find(r => r.name === 'âœµ-ã€Œaccept-submite').send(`:white_check_mark: | ØªÙ… Ù‚Ø¨ÙˆÙ„Ùƒ [ <@${message.author.id}> ]`);
                                                    }).catch();
                                                    noAcceptRe.on('collect', r => {
                                                        msgS.delete();
                                                        message.author.send(`:x: | ØªÙ… Ø±ÙØ¶Ùƒ Ø¨Ø³ÙŠØ±ÙØ± **${message.guild.name}**`);
                                                        message.guild.channels.find(r => r.name === 'âœµ-ã€Œaccept-submite').send(`:x: | ØªÙ… Ø±ÙØ¶Ùƒ [ <@${message.author.id}> ]`);
                                                    }).catch();
                                                })
                                            });// Alpha Codes
                                            dontSend.on('collect', r => {
                                                msgS.delete();
                                                message.channel.send(':x: | ØªÙ… Ø§Ù„ØºØ§Ø¡ ØªÙ‚Ø¯ÙŠÙ…Ùƒ');// Alpha Codes
                                            });
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })
    }
});

});
client.login(process.env.BOT_TOKEN);
